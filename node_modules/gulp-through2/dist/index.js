"use strict";
const PluginError = require("plugin-error");
const stream = require("stream");
const File = require("vinyl");
const defaultOptions = {
    name: "gulp-through2",
    flushEmptyList: false,
};
const defaultStreamOptions = {
    objectMode: true,
    highWaterMark: 16,
};
function isReadableStream(obj) {
    return obj !== null &&
        typeof obj === "object" &&
        typeof obj['on'] === "function" &&
        typeof obj['pipe'] === "function" &&
        typeof obj['read'] === "function";
}
const gulpThrough2 = function (options, filter) {
    if (typeof options === "function")
        options = { transform: options, filter };
    const _options = Object.assign({}, defaultOptions, options);
    const files = [];
    const err = (e) => {
        let message = "Unknown error occur";
        if (typeof e === "string")
            message = e;
        else if (e instanceof Error)
            message = e.message;
        throw new PluginError(_options.name, message);
    };
    function match(file, filter) {
        if (Array.isArray(filter))
            return filter.some(f => match(file, f));
        if (typeof filter === "string")
            return file.extname == filter;
        if (filter instanceof RegExp)
            return filter.test(file.basename);
        if (typeof filter === "function")
            return Boolean(filter(file));
        return false;
    }
    async function transform(chunk, encoding, callback) {
        function output(file) {
            if (_options.flush) {
                files.push(file);
                callback();
            }
            else {
                callback(null, file);
            }
        }
        if (!File.isVinyl(chunk)) {
            return err("Given chunk is not a vinyl file; this transformation is for Gulp streams only.");
        }
        let file = chunk;
        if (file.isNull())
            return callback();
        if (!_options.streamTransform && file.isStream())
            err("Streaming not supported.");
        if (_options.filter && !match(file, _options.filter))
            return output(file);
        try {
            if (file.isBuffer() && _options.transform) {
                encoding !== null && encoding !== void 0 ? encoding : (encoding = 'utf8');
                const content = gulpThrough2.read(file, encoding);
                const result = await _options.transform.call(this, content, file, encoding);
                if (result === null) {
                    return callback();
                }
                else if (typeof result === "string" || result instanceof String) {
                    gulpThrough2.write(file, result, encoding);
                }
                else if (File.isVinyl(result)) {
                    file = result;
                }
                else if (typeof result !== "undefined") {
                    throw "Transformed result isn't valid.";
                }
            }
            else if (file.isStream() && _options.streamTransform) {
                const result = await _options.streamTransform.call(this, file.contents, file);
                if (result === null)
                    return callback();
                if (!isReadableStream(result))
                    throw "Transformed result should be a readable stream.";
                file.contents = result;
            }
        }
        catch (e) {
            err(e);
        }
        output(file);
    }
    async function flush(callback) {
        if (_options.flush && (_options.flushEmptyList || files.length)) {
            try {
                let outFiles = await _options.flush.call(this, files);
                if (outFiles === undefined)
                    outFiles = files;
                for (const file of outFiles)
                    this.push(file);
                files.length = 0;
            }
            catch (e) {
                err(e);
            }
        }
        callback();
    }
    const streamOptions = Object.assign({}, defaultStreamOptions, _options.transformOptions);
    const streamTransform = new stream.Transform(streamOptions);
    streamTransform._transform = transform;
    streamTransform._flush = flush;
    return streamTransform;
};
gulpThrough2.read = function (file, encoding) {
    var _a, _b;
    return (_b = (_a = file.contents) === null || _a === void 0 ? void 0 : _a.toString(encoding !== null && encoding !== void 0 ? encoding : "utf8")) !== null && _b !== void 0 ? _b : "";
};
gulpThrough2.write = function (file, content, encoding) {
    file.contents = Buffer.from(content, encoding);
};
module.exports = gulpThrough2;
